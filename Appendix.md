# Appendix

部分额外说明列于此处
部分看上去难懂的用词解释单独列于此处，以避免阅读时的不畅 
部分问题与解决方案列于此处
***
## 说明:
* 哈希表只需要当作一个将某个类型的变量映射到另一类型变量的映射即可，并可以以此定位取出，不需要理解实现原理

* 为了记忆和调用的方便，哈希表被大量使用，主要以从字符串到其他内容的映射为主  
  
>以下代码演示了：在i\*128,line\*128位置，创建一个动画源是"fox"，动作是默认动作，名字为"主角"，且一开始面向270度的游戏对象，然后给它赋予半径为30像素的圆形碰撞，并添加到标准物理运算中

```java
create(i * 128, line * 128, degree(270), "主角", Implement.defaultAct, the("fox"));
unit("主角").collision = new Collision.RoundCollision(30);
physics("标准物理").add("主角");
```

* 动画是通过哈希表将字符串映射到一个图像列表\(List\<Image\>\)实现的，这是因为动画是连续的，使用List处理更加方便

***
## 用词解释:
* 全局计时器

>其实只是在运行程序时创建一个计时器，每个周期执行**锁定更新**之类的动作，同时给一个变量加一，此变量用作时间线

* 时间线

>记录游戏运行时间的整形变量，并且在 **回退** 时会转换为字符串，与**游戏对象**的**名称**一同存储，从而辨别某时刻游戏对象的状态

* 将哈希表构造为映射

>下面的 **position** 为哈希表，构造为映射后方便排序，排序的算法未列出，但其实就是解析字符串，因为字符串中存储了时间线，以此排序

```java
List<Map.Entry<String, Vector2>> list = new ArrayList<Map.Entry<String, Vector2>>(
position.entrySet());
Collections.sort(list, new Comparator<Map.Entry<String, Vector2>>() {}
```

* 闪屏

>游戏内容时隐时现地闪烁

* 双缓冲

>直接绘制图片，产生时会不同步，于是有闪屏现象，创建一个Graphics变量，将绘制内容绘制到Graphics中，再直接显示Graphics，从而同步

* 重写update函数

>默认的update会先清空内容，造成白屏闪烁

* 遍历对象绘制

>所有对象创建时有一定先后顺序，并被添加到哈希表中，但遍历哈希表显示时却有些在上层有些在下层，与添加顺序不一致

## 问题与解决方案:

* 在 **回退** 时使用哈希表存储位置和动画信息，但存储的形式似乎是散乱的

>设置时间线，将哈希表构造为映射，重写排序方法

* java标准库的图形绘制存在闪屏问题

>引入了双缓冲，并重写update函数，令其直接再调用paint

* 遍历对象绘制时似乎并没有按照添加顺序绘制

>在前置更新updateEarly添加了控制绘制层次的函数levelDraw(**动画源名称**, bg)，只要填写动画源就可以控制绘制层次的先后